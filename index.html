<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Cyberpunk Liquid Glass Editor</title>
<style>
  :root{
    --bg:#05060a; --card:rgba(255,255,255,0.04); --glass:rgba(255,255,255,0.06);
    --accent:#ff2d95; --accent-2:#ff4b3e; --muted:#9aa4b2; --radius:14px;
    --glass-blur:12px;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue";background:
    radial-gradient(1200px 600px at 10% 10%, rgba(255,45,149,0.03), transparent 8%),
    radial-gradient(900px 400px at 90% 90%, rgba(255,75,62,0.02), transparent 8%),
    var(--bg); color:#e6eef6; -webkit-font-smoothing:antialiased;}
  .wrap{max-width:1100px;margin:14px auto;padding:12px;display:grid;grid-template-columns:1fr;gap:12px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{font-size:18px;margin:0;color:#fff;letter-spacing:0.6px}
  .sub{font-size:12px;color:var(--muted)}
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:var(--radius); padding:12px; box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    backdrop-filter: blur(var(--glass-blur)) saturate(120%);
    border: 1px solid rgba(255,255,255,0.03);
  }
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button,select,input[type="range"],input[type="color"]{
    background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px 10px;border-radius:10px;
    font-size:13px;
  }
  .main{display:grid;grid-template-columns:1fr 360px;gap:12px}
  canvas{width:100%;height:auto;border-radius:12px;background:#000;display:block}
  .controls{display:flex;flex-direction:column;gap:10px;padding:8px}
  label{font-size:13px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center}
  .presets{display:flex;gap:8px;flex-wrap:wrap}
  .preset{padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);cursor:pointer;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
  .palette{display:flex;gap:6px;flex-wrap:wrap}
  .swatch{width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
  footer{font-size:12px;color:var(--muted);text-align:center;padding:6px}
  @media (max-width:920px){ .main{grid-template-columns:1fr} .controls{order:2} }
  /* cyber accents */
  .accent{color:var(--accent); font-weight:600}
  .glass-title{display:flex;gap:8px;align-items:center}
  .logo-dot{width:12px;height:12px;border-radius:50%;background:linear-gradient(180deg,var(--accent),var(--accent-2));box-shadow:0 6px 18px rgba(255,45,149,0.18)}
</style>
</head>
<body>
<div class="wrap">
  <header class="card">
    <div class="glass-title">
      <div class="logo-dot"></div>
      <div>
        <h1>Cyberpunk Liquid Glass Editor</h1>
        <div class="sub">Paleta negra · rojos · blancos · grises · efectos neón y liquid glass</div>
      </div>
    </div>
    <div class="toolbar">
      <input id="fileInput" type="file" accept="image/*,video/*" />
      <button id="btnClear">Limpiar</button>
      <button id="btnExport">Exportar imagen</button>
      <button id="btnRecord">Grabar vídeo</button>
      <select id="modeSelect" aria-label="Modo">
        <option value="cyber_neon">Neon Outline</option>
        <option value="cartoon">Cartoon</option>
        <option value="sketch">Sketch</option>
        <option value="paint">Paint</option>
        <option value="pen">Boli</option>
        <option value="oil">Óleo</option>
        <option value="comic">Cómic</option>
        <option value="manga">Manga</option>
        <option value="halftone">Halftone</option>
        <option value="watercolor">Watercolor</option>
        <option value="chroma">Chroma</option>
        <option value="gloss">Gloss</option>
        <option value="none">Sin filtro</option>
      </select>
    </div>
  </header>

  <div class="main">
    <div class="card">
      <canvas id="glcanvas" width="1280" height="960"></canvas>
      <video id="hiddenVideo" playsinline style="display:none"></video>
    </div>

    <aside class="card controls">
      <div>
        <label>Presets</label>
        <div class="presets" id="presets">
          <div class="preset" data-preset='{"mode":"cyber_neon","neonColor":"#ff2d95","neonGlow":1.2,"neonThreshold":0.18}'>Cyber Pink</div>
          <div class="preset" data-preset='{"mode":"cyber_neon","neonColor":"#00d4ff","neonGlow":1.0,"neonThreshold":0.16}'>Aqua Neon</div>
          <div class="preset" data-preset='{"mode":"cyber_neon","neonColor":"#ff4b3e","neonGlow":1.4,"neonThreshold":0.20}'>Red Glass</div>
          <div class="preset" data-preset='{"mode":"manga","intensity":0.95}'>Manga B/N</div>
        </div>
      </div>

      <div>
        <label>Intensidad</label>
        <input id="intensity" type="range" min="0" max="1" step="0.01" value="0.9" />
      </div>

      <div>
        <label>Detalle edge</label>
        <input id="edge" type="range" min="0" max="3" step="0.01" value="1.2" />
      </div>

      <div>
        <label>Posterize</label>
        <input id="posterize" type="range" min="2" max="48" step="1" value="6" />
      </div>

      <div>
        <label>Grano</label>
        <input id="grain" type="range" min="0" max="1" step="0.01" value="0.04" />
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03)">

      <div>
        <label>Neon Color</label>
        <div class="row">
          <input id="neonColor" type="color" value="#ff2d95" />
          <div class="palette" id="neonPalette" style="margin-left:8px">
            <div class="swatch" data-color="#ff2d95" style="background:#ff2d95"></div>
            <div class="swatch" data-color="#ff4b3e" style="background:#ff4b3e"></div>
            <div class="swatch" data-color="#00d4ff" style="background:#00d4ff"></div>
            <div class="swatch" data-color="#ffffff" style="background:#ffffff"></div>
            <div class="swatch" data-color="#9aa0a6" style="background:#9aa0a6"></div>
          </div>
        </div>
      </div>

      <div>
        <label>Neon Glow</label>
        <input id="neonGlow" type="range" min="0" max="2" step="0.01" value="1.2" />
      </div>

      <div>
        <label>Neon Threshold</label>
        <input id="neonThreshold" type="range" min="0" max="1" step="0.01" value="0.18" />
      </div>

      <div>
        <label>Neon Saturation</label>
        <input id="neonSat" type="range" min="0" max="3" step="0.01" value="1.4" />
      </div>

      <div class="row" style="margin-top:8px">
        <button id="fitBtn">Ajustar</button>
        <button id="centerBtn">Centrar</button>
      </div>
    </aside>
  </div>

  <footer class="card">Optimizado para iPhone · WebGL2 · Liquid Glass UI</footer>
</div>

<script>
/* ---------- WebGL helpers ---------- */
function createGL(canvas){
  const gl = canvas.getContext('webgl2', {preserveDrawingBuffer:true});
  if(!gl) throw new Error('WebGL2 no disponible');
  return gl;
}
function compileShader(gl, type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile error');
  }
  return s;
}
function createProgram(gl, vsSrc, fsSrc){
  const vs = compileShader(gl, gl.VERTEX_SHADER, vsSrc);
  const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSrc);
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p));
    throw new Error('Program link error');
  }
  return p;
}

/* ---------- Shaders ---------- */
const vs = `#version 300 es
precision highp float;
in vec2 a_pos;
out vec2 v_uv;
void main(){
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}`;

const fs = `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_tex;
uniform vec2 u_texSize;
uniform float u_intensity;
uniform float u_edge;
uniform float u_posterize;
uniform float u_grain;
uniform int u_mode;
uniform vec3 u_neonColor;
uniform float u_neonGlow;
uniform float u_neonThreshold;
uniform float u_neonSat;

vec3 sampleTex(vec2 uv){ return texture(u_tex, vec2(uv.x, 1.0 - uv.y)).rgb; }
float lum(vec3 c){ return dot(c, vec3(0.299,0.587,0.114)); }
vec3 posterize(vec3 c, float levels){ return floor(c * levels) / levels; }

// Sobel edge magnitude
float sobel(vec2 uv){
  vec2 px = 1.0 / u_texSize;
  float kx[9] = float[9](-1.0,0.0,1.0,-2.0,0.0,2.0,-1.0,0.0,1.0);
  float ky[9] = float[9](1.0,2.0,1.0,0.0,0.0,0.0,-1.0,-2.0,-1.0);
  int i=0; float gx=0.0; float gy=0.0;
  for(int y=-1;y<=1;y++){
    for(int x=-1;x<=1;x++){
      float g = lum(sampleTex(uv + vec2(float(x),float(y))*px));
      gx += kx[i]*g; gy += ky[i]*g; i++;
    }
  }
  return length(vec2(gx,gy));
}

// compute mask once and reuse
float edgeMask(vec2 uv){
  float e = sobel(uv) * u_edge;
  float m = smoothstep(u_neonThreshold*0.6, u_neonThreshold, e);
  return pow(m, 1.2);
}

// simple glow by sampling mask offsets (cheap radial approx)
float glowMask(vec2 uv){
  float acc = 0.0;
  vec2 px = 1.0 / u_texSize;
  float offs[8] = float[8](1.0,2.0,3.0,4.0,6.0,8.0,10.0,14.0);
  for(int i=0;i<8;i++){
    float r = offs[i];
    float m1 = edgeMask(uv + vec2(r,0.0)*px);
    float m2 = edgeMask(uv + vec2(-r,0.0)*px);
    float m3 = edgeMask(uv + vec2(0.0,r)*px);
    float m4 = edgeMask(uv + vec2(0.0,-r)*px);
    acc += (m1 + m2 + m3 + m4) * (1.0 / (r*0.8));
  }
  return clamp(acc * 0.06 * u_neonGlow, 0.0, 1.0);
}

// noise
float rnd(vec2 co){ return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }

void main(){
  vec3 color = sampleTex(v_uv);
  if(u_mode == 0){ outColor = vec4(color,1.0); return; }

  float mask = edgeMask(v_uv);
  float glow = glowMask(v_uv);

  // neon only on contours: strong line + halo
  if(u_mode == 1){ // cyber_neon
    vec3 neon = u_neonColor * u_neonSat;
    vec3 bg = posterize(color * 0.18 + color * 0.82, max(2.0, u_posterize)); // subtle darkened bg
    vec3 line = neon * mask * u_intensity;
    vec3 halo = neon * glow * u_intensity * 0.6;
    float noise = (rnd(v_uv * u_texSize) - 0.5) * u_grain * 0.12;
    vec3 outc = bg + halo + line + noise;
    outColor = vec4(clamp(outc, 0.0, 1.0), 1.0);
    return;
  }

  // other modes (simplified but effective)
  float edge = sobel(v_uv) * u_edge;
  float n = (rnd(v_uv * u_texSize) - 0.5) * u_grain;

  if(u_mode == 2){ // cartoon
    vec3 b = (sampleTex(v_uv + vec2(1.0/u_texSize.x,0)) + sampleTex(v_uv + vec2(-1.0/u_texSize.x,0)) + sampleTex(v_uv))/3.0;
    vec3 poster = posterize(b, max(2.0,u_posterize));
    float e = smoothstep(0.08,0.25,edge);
    vec3 outc = mix(poster, vec3(0.0), e * u_intensity) + n;
    outColor = vec4(clamp(outc,0.0,1.0),1.0); return;
  }

  if(u_mode == 3){ // sketch
    vec3 gray = vec3(lum(color));
    float e2 = smoothstep(0.05,0.35,edge);
    vec3 sketch = vec3(1.0) - gray * (1.0 + u_intensity*1.2);
    vec3 outc = mix(vec3(1.0), sketch, e2) + n*0.5;
    outColor = vec4(clamp(outc,0.0,1.0),1.0); return;
  }

  if(u_mode == 4){ // paint
    vec3 b1 = sampleTex(v_uv + vec2(1.0/u_texSize.x,0));
    vec3 b2 = sampleTex(v_uv + vec2(0,1.0/u_texSize.y));
    vec3 mixb = (b1 + b2 + color) / 3.0;
    vec3 poster = posterize(mixb, max(3.0,u_posterize));
    vec3 outc = mix(poster, color, 0.2*(1.0-u_intensity)) + n*0.6;
    outColor = vec4(clamp(outc,0.0,1.0),1.0); return;
  }

  if(u_mode == 5){ // pen
    float ink = smoothstep(0.05,0.35,edge*1.6);
    vec3 gray = vec3(lum(color));
    vec3 stroke = mix(vec3(1.0), vec3(0.0), ink * u_intensity);
    vec3 outc = clamp(mix(gray, stroke, ink*0.9) + n*0.8,0.0,1.0);
    outColor = vec4(outc,1.0); return;
  }

  if(u_mode == 6){ // oil
    vec3 b1 = sampleTex(v_uv + vec2(1.0/u_texSize.x,0));
    vec3 b2 = sampleTex(v_uv + vec2(-1.0/u_texSize.x,0));
    vec3 mixb = (b1 + b2 + color)/3.0;
    vec3 poster = posterize(mixb, max(3.0,u_posterize));
    vec3 outc = clamp(mix(color, poster, u_intensity*0.9) + n*0.6,0.0,1.0);
    outColor = vec4(outc,1.0); return;
  }

  if(u_mode == 7){ // comic
    float e2 = smoothstep(0.08,0.28,edge*1.8);
    vec3 poster = posterize(color, max(3.0,u_posterize));
    vec3 outc = mix(poster, vec3(0.0), e2 * u_intensity) + n*0.4;
    outColor = vec4(clamp(outc,0.0,1.0),1.0); return;
  }

  if(u_mode == 8){ // manga
    float e2 = smoothstep(0.06,0.28,edge*1.8);
    float gray = lum(color);
    vec2 p = v_uv * u_texSize / 6.0;
    float pattern = (sin(p.x*3.1415)*sin(p.y*3.1415));
    float screentone = mix(smoothstep(0.2,0.8,gray)*0.9, pattern*0.5+0.5,0.6);
    float final = mix(1.0, 0.0, screentone * u_intensity);
    final = mix(final, 0.0, e2 * u_intensity);
    outColor = vec4(vec3(clamp(final,0.0,1.0)),1.0); return;
  }

  if(u_mode == 9){ // halftone
    vec3 p = posterize(color, max(3.0,u_posterize));
    float gray = lum(p);
    vec2 q = v_uv * u_texSize / 6.0;
    float dots = smoothstep(0.0,1.0, gray - (sin(q.x*3.1415)*sin(q.y*3.1415))*0.25);
    vec3 outc = mix(p, vec3(dots), u_intensity) + n*0.4;
    outColor = vec4(clamp(outc,0.0,1.0),1.0); return;
  }

  if(u_mode == 10){ // watercolor
    vec3 b1 = sampleTex(v_uv + vec2(1.0/u_texSize.x,0));
    vec3 b2 = sampleTex(v_uv + vec2(0,1.0/u_texSize.y));
    vec3 mixb = mix(b1,b2,0.5);
    vec3 poster = posterize(mixb, max(3.0,u_posterize));
    vec3 outc = clamp(mix(color, poster, u_intensity*0.9) + n*0.6,0.0,1.0);
    outColor = vec4(outc,1.0); return;
  }

  if(u_mode == 11){ // chroma
    vec3 p = posterize(color, max(3.0,u_posterize));
    float lumv = lum(color);
    vec3 shift = vec3(1.0 - lumv*u_intensity, 0.6 + lumv*u_intensity*0.4, 0.8 - lumv*u_intensity*0.3);
    vec3 outc = clamp(mix(color, p * shift, u_intensity*0.9),0.0,1.0);
    outColor = vec4(outc,1.0); return;
  }

  if(u_mode == 12){ // gloss
    vec3 b = sampleTex(v_uv + vec2(1.0/u_texSize.x,0));
    float spec = pow(1.0 - smoothstep(0.0,0.6,edge),3.0) * u_intensity * 0.6;
    vec3 highlight = vec3(1.0) * spec;
    vec3 outc = clamp(mix(color,b,0.2*u_intensity) + highlight,0.0,1.0);
    outColor = vec4(outc,1.0); return;
  }

  outColor = vec4(color,1.0);
}`;

/* ---------- App state ---------- */
const canvas = document.getElementById('glcanvas');
const gl = createGL(canvas);
const program = createProgram(gl, vs, fs);
const attribPos = gl.getAttribLocation(program, 'a_pos');
const uniforms = {
  u_tex: gl.getUniformLocation(program,'u_tex'),
  u_texSize: gl.getUniformLocation(program,'u_texSize'),
  u_intensity: gl.getUniformLocation(program,'u_intensity'),
  u_edge: gl.getUniformLocation(program,'u_edge'),
  u_posterize: gl.getUniformLocation(program,'u_posterize'),
  u_grain: gl.getUniformLocation(program,'u_grain'),
  u_mode: gl.getUniformLocation(program,'u_mode'),
  u_neonColor: gl.getUniformLocation(program,'u_neonColor'),
  u_neonGlow: gl.getUniformLocation(program,'u_neonGlow'),
  u_neonThreshold: gl.getUniformLocation(program,'u_neonThreshold'),
  u_neonSat: gl.getUniformLocation(program,'u_neonSat')
};

const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

let texture = gl.createTexture();
function initTexture(){
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}
initTexture();

/* DOM */
const fileInput = document.getElementById('fileInput');
const modeSelect = document.getElementById('modeSelect');
const intensityEl = document.getElementById('intensity');
const edgeEl = document.getElementById('edge');
const posterizeEl = document.getElementById('posterize');
const grainEl = document.getElementById('grain');
const btnExport = document.getElementById('btnExport');
const btnClear = document.getElementById('btnClear');
const btnRecord = document.getElementById('btnRecord');
const presetsEl = document.getElementById('presets');
const fitBtn = document.getElementById('fitBtn');
const centerBtn = document.getElementById('centerBtn');
const neonColorEl = document.getElementById('neonColor');
const neonPalette = document.getElementById('neonPalette');
const neonGlowEl = document.getElementById('neonGlow');
const neonThresholdEl = document.getElementById('neonThreshold');
const neonSatEl = document.getElementById('neonSat');

let sourceImage = new Image();
let sourceVideo = document.getElementById('hiddenVideo');
let isVideo = false;
let playing = false;
let recorder = null;
let recordedChunks = [];

/* Resize canvas for DPR */
function resizeCanvasToDisplaySize(){
  const dpr = Math.min(window.devicePixelRatio || 1, 3);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(320, Math.floor(rect.width * dpr));
  const h = Math.max(240, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
}

/* File input */
fileInput.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  if(f.type.startsWith('video/')){
    isVideo = true;
    sourceVideo.src = url;
    sourceVideo.muted = true;
    sourceVideo.loop = true;
    try{ await sourceVideo.play(); }catch(e){}
    playing = true;
  } else {
    isVideo = false;
    sourceImage = new Image();
    sourceImage.src = url;
    await new Promise(r => sourceImage.onload = r);
  }
});

/* Presets */
presetsEl.addEventListener('click', (ev)=>{
  const p = ev.target.closest('.preset');
  if(!p) return;
  const cfg = JSON.parse(p.dataset.preset);
  if(cfg.mode) modeSelect.value = cfg.mode;
  if(cfg.neonColor) neonColorEl.value = cfg.neonColor;
  if(cfg.neonGlow) neonGlowEl.value = cfg.neonGlow;
  if(cfg.neonThreshold) neonThresholdEl.value = cfg.neonThreshold;
  if(cfg.intensity) intensityEl.value = cfg.intensity;
  if(cfg.posterize) posterizeEl.value = cfg.posterize;
});

/* Neon palette quick pick */
neonPalette.addEventListener('click', (ev)=>{
  const s = ev.target.closest('.swatch');
  if(!s) return;
  neonColorEl.value = s.dataset.color;
});

/* Buttons */
btnClear.addEventListener('click', ()=>{
  isVideo = false; playing = false;
  sourceImage = new Image();
  sourceVideo.pause();
  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
});
btnExport.addEventListener('click', ()=>{
  const data = canvas.toDataURL('image/png');
  const a = document.createElement('a'); a.href = data; a.download = 'cyber_edit.png'; a.click();
});

/* Recording */
btnRecord.addEventListener('click', async ()=>{
  if(recorder && recorder.state === 'recording'){ recorder.stop(); btnRecord.textContent='Grabar vídeo'; return; }
  recordedChunks = [];
  const stream = canvas.captureStream(30);
  try{ recorder = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'}); }catch(e){ recorder = new MediaRecorder(stream); }
  recorder.ondataavailable = e => { if(e.data.size) recordedChunks.push(e.data); };
  recorder.onstop = () => {
    const blob = new Blob(recordedChunks, {type:'video/webm'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'cyber_recording.webm'; a.click();
    URL.revokeObjectURL(url);
  };
  recorder.start(); btnRecord.textContent='Detener';
});

/* Fit / Center placeholders */
fitBtn.addEventListener('click', ()=>{ alert('Ajustar al lienzo: implementado en próxima iteración'); });
centerBtn.addEventListener('click', ()=>{ alert('Centrar: implementado en próxima iteración'); });

/* Render loop */
function updateTextureFromSource(){
  gl.bindTexture(gl.TEXTURE_2D, texture);
  if(isVideo && playing){
    try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,sourceVideo); }catch(e){}
  } else if(sourceImage && sourceImage.complete && sourceImage.naturalWidth){
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,sourceImage);
  } else {
    const blank = new Uint8Array([10,10,12,255]);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,blank);
  }
}

function hexToVec3(hex){
  const h = hex.replace('#','');
  return [parseInt(h.substring(0,2),16)/255, parseInt(h.substring(2,4),16)/255, parseInt(h.substring(4,6),16)/255];
}

function render(){
  resizeCanvasToDisplaySize();
  updateTextureFromSource();

  gl.useProgram(program);
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
  gl.enableVertexAttribArray(attribPos);
  gl.vertexAttribPointer(attribPos, 2, gl.FLOAT, false, 0, 0);

  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.uniform1i(uniforms.u_tex, 0);
  gl.uniform2f(uniforms.u_texSize, canvas.width, canvas.height);
  gl.uniform1f(uniforms.u_intensity, parseFloat(intensityEl.value));
  gl.uniform1f(uniforms.u_edge, parseFloat(edgeEl.value));
  gl.uniform1f(uniforms.u_posterize, parseFloat(posterizeEl.value));
  gl.uniform1f(uniforms.u_grain, parseFloat(grainEl.value));
  const modeMap = {none:0, cyber_neon:1, cartoon:2, sketch:3, paint:4, pen:5, oil:6, comic:7, manga:8, halftone:9, watercolor:10, chroma:11, gloss:12};
  gl.uniform1i(uniforms.u_mode, modeMap[modeSelect.value] ?? 0);

  const neonVec = hexToVec3(neonColorEl.value);
  gl.uniform3f(uniforms.u_neonColor, neonVec[0], neonVec[1], neonVec[2]);
  gl.uniform1f(uniforms.u_neonGlow, parseFloat(neonGlowEl.value));
  gl.uniform1f(uniforms.u_neonThreshold, parseFloat(neonThresholdEl.value));
  gl.uniform1f(uniforms.u_neonSat, parseFloat(neonSatEl.value));

  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/* UX */
canvas.addEventListener('click', ()=> fileInput.click());
sourceVideo.addEventListener('play', ()=>{ playing = true; });
sourceVideo.addEventListener('pause', ()=>{ playing = false; });

</script>
</body>
</html>
