<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Editor de Efectos Art√≠sticos Pro</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
  :root{
    --bg:#0a0a0a;
    --panel:#141414;
    --accent:#ff5c5c;
    --accent-soft:#ffb347;
    --accent-cyan:#00d4ff;
    --text:#ffffff;
    --muted:#888888;
    --border:#2a2a2a;
  }
  *{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;}
  body{
    background:radial-gradient(circle at top,#1a1a1a 0,#000 60%,#000 100%);
    color:var(--text);
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:12px;
  }
  .app{
    width:100%;
    max-width:1400px;
    background:var(--bg);
    border-radius:20px;
    box-shadow:0 0 60px rgba(255,92,92,0.15);
    overflow:hidden;
    border:1px solid var(--border);
  }
  header{
    padding:16px 20px;
    border-bottom:1px solid var(--border);
    display:flex;
    flex-wrap:wrap;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    background:linear-gradient(135deg,#0f0f0f,#1a1a1a 40%,#222);
  }
  header h1{
    font-size:1.2rem;
    letter-spacing:0.04em;
    background:linear-gradient(120deg,#ff5c5c,#ffb347,#00d4ff);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
  }
  .badge{
    font-size:0.65rem;
    padding:3px 8px;
    border-radius:12px;
    background:#222;
    color:var(--accent-cyan);
    border:1px solid #333;
    text-transform:uppercase;
    letter-spacing:0.05em;
  }
  main{display:flex;flex-direction:column;}
  .layout{display:flex;flex-direction:column;}
  @media(min-width:980px){
    .layout{flex-direction:row;}
  }
  .panel{padding:16px;}
  .panel.controls{
    background:var(--panel);
    border-right:1px solid var(--border);
    min-width:280px;
    max-height:90vh;
    overflow-y:auto;
    -webkit-overflow-scrolling:touch;
  }
  @media(min-width:980px){
    .panel.controls{width:360px;}
  }
  .panel.preview{
    flex:1;
    background:#000;
  }
  .section-title{
    font-size:0.85rem;
    text-transform:uppercase;
    color:var(--muted);
    letter-spacing:0.15em;
    margin:16px 0 10px;
    border-bottom:1px solid #222;
    padding-bottom:6px;
  }
  .section-title:first-child{margin-top:0;}
  .input-group{margin-bottom:12px;}
  label{
    display:block;
    font-size:0.82rem;
    margin-bottom:5px;
    color:#ccc;
  }
  .file-drop{
    border:2px dashed var(--border);
    border-radius:14px;
    padding:18px;
    text-align:center;
    position:relative;
    background:#0f0f0f;
    transition:all 0.2s;
  }
  .file-drop.dragover{
    border-color:var(--accent);
    background:#1a1a1a;
    transform:scale(1.02);
  }
  /* FIX iOS: El input NO puede estar oculto */
  .file-drop input[type="file"]{
    opacity:1 !important;
    position:relative !important;
    width:100%;
    padding:10px;
    font-size:14px;
    cursor:pointer;
    background:#1a1a1a;
    border:1px solid #333;
    border-radius:8px;
    color:#fff;
  }
  .file-drop p{
    font-size:0.75rem;
    color:var(--muted);
    margin-bottom:8px;
  }
  select, input[type="range"], input[type="color"], input[type="text"]{width:100%;}
  select, input[type="text"]{
    padding:8px 10px;
    border-radius:10px;
    border:1px solid var(--border);
    background:#0a0a0a;
    color:var(--text);
    font-size:0.85rem;
  }
  .range-row{
    display:flex;
    align-items:center;
    gap:10px;
  }
  .range-value{
    min-width:40px;
    text-align:right;
    font-size:0.8rem;
    color:var(--accent-soft);
    font-weight:600;
  }
  input[type="range"]{
    -webkit-appearance:none;
    appearance:none;
    height:5px;
    border-radius:999px;
    background:linear-gradient(to right,#222,#444);
    outline:none;
  }
  input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none;
    appearance:none;
    width:18px;
    height:18px;
    border-radius:50%;
    background:linear-gradient(135deg,var(--accent),var(--accent-soft));
    cursor:pointer;
    border:2px solid #000;
    box-shadow:0 0 8px rgba(255,92,92,0.5);
  }
  input[type="range"]::-moz-range-thumb{
    width:18px;
    height:18px;
    border-radius:50%;
    background:var(--accent);
    border:none;
    cursor:pointer;
  }
  input[type="color"]{
    border-radius:10px;
    border:1px solid var(--border);
    height:38px;
    padding:2px;
    background:#000;
  }
  .toggles{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    margin-top:4px;
  }
  .toggle{
    display:flex;
    align-items:center;
    gap:5px;
    font-size:0.76rem;
    color:#aaa;
    cursor:pointer;
  }
  .toggle input{cursor:pointer;}
  .buttons{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-top:12px;
  }
  button{
    border:none;
    border-radius:999px;
    padding:9px 16px;
    font-size:0.8rem;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:6px;
    background:#1a1a1a;
    color:var(--text);
    transition:all 0.2s;
    border:1px solid transparent;
    -webkit-tap-highlight-color:transparent;
  }
  button.primary{
    background:linear-gradient(120deg,#ff5c5c,#ffb347);
    color:#000;
    font-weight:600;
    box-shadow:0 0 16px rgba(255,92,92,0.4);
  }
  button.secondary{
    background:#222;
    border-color:#333;
  }
  button.ghost{
    background:transparent;
    border:1px solid var(--border);
  }
  button.accent{
    background:var(--accent-cyan);
    color:#000;
    font-weight:600;
  }
  button:disabled{
    opacity:0.3;
    cursor:not-allowed;
    box-shadow:none;
  }
  button:active{
    transform:scale(0.96);
  }
  .hint{
    font-size:0.7rem;
    color:var(--muted);
    margin-top:6px;
    line-height:1.4;
  }
  .canvas-wrapper{
    position:relative;
    width:100%;
    min-height:400px;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
  }
  canvas{
    max-width:100%;
    max-height:85vh;
    background:#000;
    display:block;
  }
  #canvasMask{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    pointer-events:none;
    opacity:0.7;
  }
  #canvasMask.active{
    pointer-events:all;
    cursor:crosshair;
  }
  .placeholder{
    text-align:center;
    color:var(--muted);
    font-size:0.9rem;
    padding:40px 20px;
  }
  .spinner{
    position:absolute;
    inset:auto 16px 16px auto;
    width:32px;
    height:32px;
    border-radius:50%;
    border:4px solid rgba(255,255,255,0.1);
    border-top-color:var(--accent-soft);
    animation:spin 0.8s linear infinite;
    display:none;
    z-index:10;
  }
  .spinner.visible{display:block;}
  @keyframes spin{to{transform:rotate(360deg);}}
  .mode-indicator{
    position:absolute;
    top:16px;
    left:16px;
    background:rgba(0,0,0,0.8);
    padding:6px 12px;
    border-radius:20px;
    font-size:0.75rem;
    color:var(--accent-cyan);
    border:1px solid rgba(0,212,255,0.3);
    display:none;
  }
  .mode-indicator.visible{display:block;}
  .preset-grid{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(100px,1fr));
    gap:8px;
    margin-top:8px;
  }
  .preset-card{
    background:#1a1a1a;
    border:1px solid #333;
    border-radius:10px;
    padding:8px;
    cursor:pointer;
    text-align:center;
    transition:all 0.2s;
  }
  .preset-card:active{
    background:#252525;
    border-color:var(--accent);
    transform:translateY(-2px);
  }
  .preset-card .name{
    font-size:0.75rem;
    color:#fff;
    margin-bottom:3px;
  }
  .preset-card .effect{
    font-size:0.65rem;
    color:var(--muted);
  }
  .preset-card .delete{
    font-size:0.7rem;
    color:#f44;
    margin-top:4px;
    opacity:0.7;
  }
  .mask-controls{
    display:none;
    background:#1a1a1a;
    padding:10px;
    border-radius:10px;
    margin-top:8px;
    border:1px solid #333;
  }
  .mask-controls.visible{display:block;}
  .debug-info{
    font-size:0.7rem;
    color:#0f0;
    background:#001100;
    padding:4px 8px;
    border-radius:4px;
    margin-top:8px;
    font-family:monospace;
  }
</style>
</head>
<body>
<div class="app" aria-label="Editor de efectos art√≠sticos profesional">
  <header>
    <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
      <h1>‚ú® Editor de Efectos Art√≠sticos Pro</h1>
      <span class="badge">iOS Optimizado</span>
    </div>
    <span style="font-size:0.75rem;color:var(--muted);">100% privado ¬∑ Todo en tu iPhone</span>
  </header>

  <main>
    <div class="layout">
      <!-- Panel de controles -->
      <section class="panel controls" aria-label="Controles de edici√≥n">
        
        <div class="section-title">üì∏ Imagen</div>
        <div class="input-group">
          <div class="file-drop" id="zonaDrop">
            <p><strong>üìÅ Seleccionar foto</strong></p>
            <!-- FIX iOS: input visible, NO oculto, accept simplificado -->
            <input id="fileInput" type="file" accept="image/*" capture="environment" aria-label="Subir imagen" />
          </div>
          <div id="debugInfo" class="debug-info" style="display:none;"></div>
        </div>

        <div class="section-title">üé® Efecto</div>
        <div class="input-group">
          <label for="selectEfecto">Estilo art√≠stico:</label>
          <select id="selectEfecto" aria-label="Elegir efecto art√≠stico">
            <optgroup label="üî• Cl√°sicos">
              <option value="neon">‚ö° Ne√≥n intenso</option>
              <option value="cartoon">üé≠ Cartoon cl√°sico</option>
              <option value="simpsons">üíõ Estilo Simpsons</option>
              <option value="boceto">‚úèÔ∏è Boceto a l√°piz</option>
              <option value="poster">üé® Posterizado pop</option>
              <option value="oleo">üñåÔ∏è Pintura al √≥leo</option>
            </optgroup>
            <optgroup label="‚ú® Nuevos Efectos">
              <option value="acuarela">üíß Acuarela</option>
              <option value="comic-bw">üì∞ C√≥mic blanco y negro</option>
              <option value="glitch">üì∫ Glitch RGB</option>
            </optgroup>
          </select>
        </div>

        <div class="section-title">‚öôÔ∏è Ajustes</div>

        <div class="input-group" id="grupoUmbral">
          <label for="umbralBordes">Umbral de bordes</label>
          <div class="range-row">
            <input id="umbralBordes" type="range" min="20" max="150" value="80" />
            <span class="range-value" id="valUmbral">80</span>
          </div>
        </div>

        <div class="input-group" id="grupoGlow">
          <label for="intensidadGlow">Intensidad de brillo</label>
          <div class="range-row">
            <input id="intensidadGlow" type="range" min="5" max="50" value="25" />
            <span class="range-value" id="valGlow">25</span>
          </div>
        </div>

        <div class="input-group">
          <label for="nitidez">Nitidez</label>
          <div class="range-row">
            <input id="nitidez" type="range" min="-50" max="100" value="20" />
            <span class="range-value" id="valNitidez">20</span>
          </div>
        </div>

        <div class="input-group">
          <label for="mezcla">Mezcla con original (%)</label>
          <div class="range-row">
            <input id="mezcla" type="range" min="0" max="100" value="70" />
            <span class="range-value" id="valMezcla">70%</span>
          </div>
        </div>

        <div class="input-group" id="grupoColor">
          <label for="colorPrincipal">Color principal</label>
          <input id="colorPrincipal" type="color" value="#ff4500" />
        </div>

        <div class="input-group" id="grupoGrosor">
          <label for="grosorLineas">Grosor de l√≠neas</label>
          <div class="range-row">
            <input id="grosorLineas" type="range" min="1" max="10" value="3" />
            <span class="range-value" id="valGrosor">3px</span>
          </div>
        </div>

        <div class="toggles">
          <label class="toggle">
            <input id="soloContornos" type="checkbox" />
            <span>Solo contornos</span>
          </label>
          <label class="toggle">
            <input id="invertir" type="checkbox" />
            <span>Invertir</span>
          </label>
          <label class="toggle">
            <input id="splitView" type="checkbox" />
            <span>Vista dividida</span>
          </label>
        </div>

        <div class="section-title">üíæ Presets guardados</div>
        <div class="input-group">
          <input id="presetName" type="text" placeholder="Nombre del preset..." />
          <div class="buttons">
            <button id="btnSavePreset" class="secondary">Guardar preset</button>
          </div>
        </div>
        <div class="preset-grid" id="presetGrid"></div>

        <div class="section-title">üöÄ Acciones</div>
        <div class="buttons">
          <button class="primary" id="btnAplicar">Aplicar efecto</button>
          <button class="secondary" id="btnRestablecer">Restablecer</button>
        </div>
        <div class="buttons">
          <button class="accent" id="btnDescargar" disabled>‚¨áÔ∏è Descargar PNG</button>
        </div>
        
      </section>

      <!-- Panel de vista previa -->
      <section class="panel preview" aria-label="Vista previa de la imagen">
        <div class="canvas-wrapper">
          <canvas id="canvas"></canvas>
          <div id="placeholder" class="placeholder">
            üñºÔ∏è Selecciona una foto para empezar<br>
            <span style="font-size:0.75rem;color:#666;">Optimizado para iPhone 16 Pro</span>
          </div>
          <div id="spinner" class="spinner" aria-hidden="true"></div>
          <div id="modeIndicator" class="mode-indicator">üñåÔ∏è Procesando...</div>
        </div>
      </section>
    </div>
  </main>
</div>

<script>
(() => {
  'use strict';
  
  console.log('üöÄ Iniciando app...');
  
  // ========== DOM Elements ==========
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', {willReadFrequently: true});
  
  const fileInput = document.getElementById('fileInput');
  const selectEfecto = document.getElementById('selectEfecto');
  const placeholder = document.getElementById('placeholder');
  const spinner = document.getElementById('spinner');
  const modeIndicator = document.getElementById('modeIndicator');
  const debugInfo = document.getElementById('debugInfo');

  const umbralBordes = document.getElementById('umbralBordes');
  const intensidadGlow = document.getElementById('intensidadGlow');
  const nitidez = document.getElementById('nitidez');
  const mezcla = document.getElementById('mezcla');
  const colorPrincipal = document.getElementById('colorPrincipal');
  const grosorLineas = document.getElementById('grosorLineas');
  const soloContornos = document.getElementById('soloContornos');
  const invertir = document.getElementById('invertir');
  const splitView = document.getElementById('splitView');

  const valUmbral = document.getElementById('valUmbral');
  const valGlow = document.getElementById('valGlow');
  const valNitidez = document.getElementById('valNitidez');
  const valMezcla = document.getElementById('valMezcla');
  const valGrosor = document.getElementById('valGrosor');

  const grupoGlow = document.getElementById('grupoGlow');
  const grupoColor = document.getElementById('grupoColor');
  const grupoGrosor = document.getElementById('grupoGrosor');
  const grupoUmbral = document.getElementById('grupoUmbral');

  const btnAplicar = document.getElementById('btnAplicar');
  const btnRestablecer = document.getElementById('btnRestablecer');
  const btnDescargar = document.getElementById('btnDescargar');
  const btnSavePreset = document.getElementById('btnSavePreset');
  const presetName = document.getElementById('presetName');
  const presetGrid = document.getElementById('presetGrid');

  // ========== State ==========
  let imagenOriginal = null;
  let imagenBase = null;
  let processingTimeout = null;

  // ========== Utility Functions ==========
  function log(msg){
    console.log(msg);
    debugInfo.textContent = msg;
    debugInfo.style.display = 'block';
  }

  function mostrarSpinner(mostrar){
    spinner.classList.toggle('visible', !!mostrar);
    modeIndicator.classList.toggle('visible', !!mostrar);
  }

  function clamp(v, min, max){
    return v < min ? min : (v > max ? max : v);
  }

  function cargarImagen(archivo){
    if(!archivo) {
      log('‚ùå No se seleccion√≥ archivo');
      return;
    }
    
    log(`üìÑ Archivo: ${archivo.name} (${(archivo.size/1024/1024).toFixed(2)}MB)`);
    
    const reader = new FileReader();
    
    reader.onerror = (e) => {
      log(`‚ùå Error FileReader: ${e.target.error}`);
    };
    
    reader.onload = e => {
      log('‚úÖ FileReader completado');
      const img = new Image();
      
      img.onerror = () => {
        log('‚ùå Error al cargar imagen');
      };
      
      img.onload = () => {
        log(`‚úÖ Imagen cargada: ${img.width}x${img.height}`);
        imagenBase = img;
        redimensionarYGuardarOriginal();
        btnDescargar.disabled = false;
      };
      
      img.src = e.target.result;
    };
    
    // FIX iOS: Leer inmediatamente para evitar timeout de 60s
    reader.readAsDataURL(archivo);
  }

  function redimensionarYGuardarOriginal(){
    if(!imagenBase) return;
    
    // FIX iOS: Reducir tama√±o m√°ximo para evitar l√≠mites de memoria
    const maxDim = 1500; // Reducido de 2000 para iOS
    let w = imagenBase.width;
    let h = imagenBase.height;
    const ratio = Math.min(1, maxDim / Math.max(w,h));
    w = Math.round(w * ratio);
    h = Math.round(h * ratio);
    
    canvas.width = w;
    canvas.height = h;
    
    log(`üìê Canvas: ${w}x${h}`);
    
    ctx.drawImage(imagenBase, 0, 0, w, h);
    imagenOriginal = ctx.getImageData(0,0,w,h);
    
    placeholder.style.display = 'none';
    log('‚úÖ Listo para aplicar efectos');
    aplicarEfectoSeleccionadoDebounced();
  }

  function hexToRgb(hex){
    const clean = hex.replace('#','');
    const bigint = parseInt(clean,16);
    return {
      r:(bigint>>16)&255,
      g:(bigint>>8)&255,
      b:bigint&255
    };
  }

  function obtenerParametros(){
    return {
      umbral: parseInt(umbralBordes.value,10),
      glow: parseInt(intensidadGlow.value,10),
      nitidez: parseInt(nitidez.value,10),
      mezcla: parseInt(mezcla.value,10)/100,
      color: hexToRgb(colorPrincipal.value),
      grosor: parseInt(grosorLineas.value,10),
      soloContornos: soloContornos.checked,
      invertir: invertir.checked
    };
  }

  // ========== Effect Processing ==========
  function aplicarEfectoSeleccionadoDebounced(){
    if(!imagenOriginal) return;
    clearTimeout(processingTimeout);
    processingTimeout = setTimeout(aplicarEfectoSeleccionado, 100);
  }

  function aplicarEfectoSeleccionado(){
    if(!imagenOriginal) return;
    mostrarSpinner(true);
    
    // FIX iOS: Usar setTimeout para evitar bloquear UI
    setTimeout(() => {
      try {
        const w = imagenOriginal.width;
        const h = imagenOriginal.height;
        const imgData = new ImageData(new Uint8ClampedArray(imagenOriginal.data), w, h);
        let procesada = imgData;

        const params = obtenerParametros();
        const efecto = selectEfecto.value;

        switch(efecto){
          case 'neon': procesada = aplicarNeon(procesada, params); break;
          case 'cartoon': procesada = aplicarCartoon(procesada, params); break;
          case 'simpsons': procesada = aplicarSimpsons(procesada, params); break;
          case 'boceto': procesada = aplicarBoceto(procesada, params); break;
          case 'poster': procesada = aplicarPosterizado(procesada, params); break;
          case 'oleo': procesada = aplicarOleo(procesada, params); break;
          case 'acuarela': procesada = aplicarAcuarela(procesada, params); break;
          case 'comic-bw': procesada = aplicarComicBW(procesada, params); break;
          case 'glitch': procesada = aplicarGlitch(procesada, params); break;
        }

        if(params.nitidez !== 0){
          procesada = ajustarNitidez(procesada, params.nitidez);
        }

        procesada = mezclarConOriginal(procesada, imagenOriginal, params.mezcla);

        if(params.invertir){
          procesada = invertirColores(procesada);
        }

        ctx.clearRect(0,0,w,h);
        if(splitView.checked){
          ctx.putImageData(imagenOriginal,0,0);
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = w;
          tempCanvas.height = h;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.putImageData(procesada,0,0);
          ctx.drawImage(tempCanvas, Math.floor(w/2),0,Math.ceil(w/2),h, Math.floor(w/2),0,Math.ceil(w/2),h);
          ctx.strokeStyle = 'rgba(255,255,255,0.6)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(Math.floor(w/2),0);
          ctx.lineTo(Math.floor(w/2),h);
          ctx.stroke();
        }else{
          ctx.putImageData(procesada,0,0);
        }

        log('‚úÖ Efecto aplicado');
        mostrarSpinner(false);
      } catch(e) {
        log(`‚ùå Error: ${e.message}`);
        mostrarSpinner(false);
      }
    }, 50);
  }

  function mezclarConOriginal(procesada, original, factor){
    const w = original.width, h = original.height;
    const o = original.data;
    const p = procesada.data;
    const out = new Uint8ClampedArray(o.length);
    for(let i=0;i<o.length;i+=4){
      out[i]   = clamp(o[i]*(1-factor)   + p[i]*factor,0,255);
      out[i+1] = clamp(o[i+1]*(1-factor) + p[i+1]*factor,0,255);
      out[i+2] = clamp(o[i+2]*(1-factor) + p[i+2]*factor,0,255);
      out[i+3] = 255;
    }
    return new ImageData(out,w,h);
  }

  function invertirColores(imgData){
    const d = imgData.data;
    for(let i=0;i<d.length;i+=4){
      d[i] = 255-d[i];
      d[i+1] = 255-d[i+1];
      d[i+2] = 255-d[i+2];
    }
    return imgData;
  }

  function ajustarNitidez(imgData, amount){
    if(amount === 0) return imgData;
    const w = imgData.width, h = imgData.height;
    const src = imgData.data;
    const out = new Uint8ClampedArray(src.length);
    const kBase = [0,-1,0,-1,5,-1,0,-1,0];
    const strength = amount > 0 ? 1 + amount/50 : 1 + amount/100;
    const k = kBase.map(v => v * strength);
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        let r=0,g=0,b=0,ki=0;
        for(let ky=-1;ky<=1;ky++){
          for(let kx=-1;kx<=1;kx++){
            const idx = ((y+ky)*w+(x+kx))*4;
            const kv = k[ki++];
            r += src[idx]*kv;
            g += src[idx+1]*kv;
            b += src[idx+2]*kv;
          }
        }
        const o = (y*w+x)*4;
        out[o]   = clamp(r,0,255);
        out[o+1] = clamp(g,0,255);
        out[o+2] = clamp(b,0,255);
        out[o+3] = 255;
      }
    }
    return new ImageData(out,w,h);
  }

  function detectarBordesSobel(imgData){
    const w = imgData.width;
    const h = imgData.height;
    const src = imgData.data;
    const out = new Uint8ClampedArray(w*h*4);

    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        let gx=0, gy=0;
        const kernel = [
          [((y-1)*w+(x-1))*4, -1, -1],
          [((y-1)*w+x)*4, 0, -2],
          [((y-1)*w+(x+1))*4, 1, -1],
          [(y*w+(x-1))*4, -2, 0],
          [(y*w+(x+1))*4, 2, 0],
          [((y+1)*w+(x-1))*4, -1, 1],
          [((y+1)*w+x)*4, 0, 2],
          [((y+1)*w+(x+1))*4, 1, 1]
        ];
        for(const [idx, kx, ky] of kernel){
          const gray = (src[idx]+src[idx+1]+src[idx+2])/3;
          gx += gray * kx;
          gy += gray * ky;
        }
        const mag = Math.sqrt(gx*gx + gy*gy);
        const v = clamp(mag,0,255);
        const o = (y*w+x)*4;
        out[o]=out[o+1]=out[o+2]=v;
        out[o+3]=255;
      }
    }
    return new ImageData(out,w,h);
  }

  function cuantizarColor(imgData, niveles){
    const d = imgData.data;
    const step = 255/(niveles-1);
    for(let i=0;i<d.length;i+=4){
      d[i]   = Math.round(d[i]/step)*step;
      d[i+1] = Math.round(d[i+1]/step)*step;
      d[i+2] = Math.round(d[i+2]/step)*step;
    }
    return imgData;
  }

  // ========== Effects ==========
  function aplicarNeon(imgData, params){
    const edges = detectarBordesSobel(imgData);
    const w = imgData.width, h = imgData.height;
    const out = ctx.createImageData(w,h);
    const dst = out.data;
    const e = edges.data;
    const color = params.color;
    const umbral = params.umbral;

    for(let i=0;i<e.length;i+=4){
      const v = e[i];
      if(v > umbral){
        dst[i]=color.r;
        dst[i+1]=color.g;
        dst[i+2]=color.b;
        dst[i+3]=255;
      }else{
        dst[i]=dst[i+1]=dst[i+2]=0;
        dst[i+3]=params.soloContornos?0:255;
      }
    }
    return out;
  }

  function aplicarCartoon(imgData, params){
    const res = cuantizarColor(new ImageData(new Uint8ClampedArray(imgData.data), imgData.width, imgData.height), 10);
    const edges = detectarBordesSobel(imgData);
    const dst = res.data;
    const e = edges.data;
    const umbral = params.umbral;

    for(let i=0;i<e.length;i+=4){
      if(e[i] > umbral){
        dst[i]=dst[i+1]=dst[i+2]=0;
        dst[i+3]=255;
      }
    }
    return res;
  }

  function aplicarSimpsons(imgData, params){
    const d = imgData.data;
    for(let i=0;i<d.length;i+=4){
      const r=d[i], g=d[i+1], b=d[i+2];
      const isSkin = r>g && g>b && r>60 && g>40;
      if(isSkin){
        d[i]   = params.color.r;
        d[i+1] = params.color.g;
        d[i+2] = params.color.b;
      }else{
        const avg=(r+g+b)/3;
        d[i]   = clamp(avg + (r-avg)*1.3,0,255);
        d[i+1] = clamp(avg + (g-avg)*1.3,0,255);
        d[i+2] = clamp(avg + (b-avg)*1.3,0,255);
      }
    }
    const edges = detectarBordesSobel(imgData);
    const e = edges.data;
    const umbral = params.umbral;
    for(let i=0;i<e.length;i+=4){
      if(e[i] > umbral){
        d[i]=d[i+1]=d[i+2]=0;
      }
    }
    return imgData;
  }

  function aplicarBoceto(imgData, params){
    const w = imgData.width, h = imgData.height;
    const gray = new Uint8ClampedArray(w*h*4);
    const src = imgData.data;
    for(let i=0;i<src.length;i+=4){
      const g = (src[i]+src[i+1]+src[i+2])/3;
      gray[i]=gray[i+1]=gray[i+2]=g;
      gray[i+3]=255;
    }
    const grayImg = new ImageData(gray,w,h);
    const edges = detectarBordesSobel(grayImg);
    const dst = ctx.createImageData(w,h);
    const e = edges.data;
    const umbral = params.umbral;
    for(let i=0;i<e.length;i+=4){
      const c = e[i]>umbral ? 0:255;
      dst.data[i]=dst.data[i+1]=dst.data[i+2]=c;
      dst.data[i+3]=255;
    }
    return dst;
  }

  function aplicarPosterizado(imgData, params){
    return cuantizarColor(new ImageData(new Uint8ClampedArray(imgData.data), imgData.width, imgData.height), 6);
  }

  function aplicarOleo(imgData, params){
    const radius = 2; // Reducido para iOS
    const intensity = 15;
    const w = imgData.width, h = imgData.height;
    const src = imgData.data;
    const out = ctx.createImageData(w,h);
    const dst = out.data;
    
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const bins = [];
        for(let yy=-radius;yy<=radius;yy++){
          for(let xx=-radius;xx<=radius;xx++){
            const ny=y+yy, nx=x+xx;
            if(ny<0||ny>=h||nx<0||nx>=w) continue;
            const idx=(ny*w+nx)*4;
            const r=src[idx], g=src[idx+1], b=src[idx+2];
            const avg=(r+g+b)/3;
            const bin=Math.floor((avg*intensity)/255);
            if(!bins[bin]) bins[bin]={count:0,r:0,g:0,b:0};
            bins[bin].count++;
            bins[bin].r+=r;
            bins[bin].g+=g;
            bins[bin].b+=b;
          }
        }
        let maxBin = null;
        for(const bin of bins){
          if(bin && (!maxBin || bin.count > maxBin.count)){
            maxBin = bin;
          }
        }
        const o=(y*w+x)*4;
        if(maxBin){
          dst[o]=maxBin.r/maxBin.count;
          dst[o+1]=maxBin.g/maxBin.count;
          dst[o+2]=maxBin.b/maxBin.count;
          dst[o+3]=255;
        }
      }
    }
    return out;
  }

  function aplicarAcuarela(imgData, params){
    let result = cuantizarColor(new ImageData(new Uint8ClampedArray(imgData.data), imgData.width, imgData.height), 12);
    const edges = detectarBordesSobel(imgData);
    const e = edges.data;
    const d = result.data;
    for(let i=0;i<e.length;i+=4){
      if(e[i] > 100){
        const factor = 0.3;
        d[i] *= (1-factor);
        d[i+1] *= (1-factor);
        d[i+2] *= (1-factor);
      }
    }
    return result;
  }

  function aplicarComicBW(imgData, params){
    const w = imgData.width, h = imgData.height;
    const src = imgData.data;
    const out = ctx.createImageData(w,h);
    const dst = out.data;

    for(let i=0;i<src.length;i+=4){
      const gray = (src[i]+src[i+1]+src[i+2])/3;
      const threshold = 128;
      const val = gray > threshold ? 255 : 0;
      dst[i]=dst[i+1]=dst[i+2]=val;
      dst[i+3]=255;
    }

    const edges = detectarBordesSobel(imgData);
    const e = edges.data;
    for(let i=0;i<e.length;i+=4){
      if(e[i] > 80){
        dst[i]=dst[i+1]=dst[i+2]=0;
      }
    }
    return out;
  }

  function aplicarGlitch(imgData, params){
    const w = imgData.width, h = imgData.height;
    const src = imgData.data;
    const out = ctx.createImageData(w,h);
    const dst = out.data;

    const shiftR = 5;
    const shiftG = -3;

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const idx = (y*w+x)*4;
        const xR = clamp(x+shiftR, 0, w-1);
        const xG = clamp(x+shiftG, 0, w-1);

        dst[idx]   = src[(y*w+xR)*4];
        dst[idx+1] = src[(y*w+xG)*4+1];
        dst[idx+2] = src[(y*w+x)*4+2];
        dst[idx+3] = 255;
      }
    }

    for(let y=0;y<h;y+=3){
      if(Math.random() > 0.7){
        for(let x=0;x<w;x++){
          const idx = (y*w+x)*4;
          dst[idx] *= 0.7;
          dst[idx+1] *= 0.7;
          dst[idx+2] *= 0.7;
        }
      }
    }
    return out;
  }

  // ========== Presets ==========
  function savePreset(){
    const name = presetName.value.trim();
    if(!name) {
      alert('Por favor, introduce un nombre para el preset');
      return;
    }

    const preset = {
      name,
      efecto: selectEfecto.value,
      umbral: umbralBordes.value,
      glow: intensidadGlow.value,
      nitidez: nitidez.value,
      mezcla: mezcla.value,
      color: colorPrincipal.value,
      grosor: grosorLineas.value,
      soloContornos: soloContornos.checked,
      invertir: invertir.checked
    };

    let presets = JSON.parse(localStorage.getItem('artEffectsPresets') || '[]');
    presets.push(preset);
    localStorage.setItem('artEffectsPresets', JSON.stringify(presets));
    
    presetName.value = '';
    loadPresets();
  }

  function loadPresets(){
    const presets = JSON.parse(localStorage.getItem('artEffectsPresets') || '[]');
    presetGrid.innerHTML = '';
    
    presets.forEach((preset, index) => {
      const card = document.createElement('div');
      card.className = 'preset-card';
      card.innerHTML = `
        <div class="name">${preset.name}</div>
        <div class="effect">${preset.efecto}</div>
        <div class="delete" data-index="${index}">üóëÔ∏è</div>
      `;
      
      card.addEventListener('click', e => {
        if(e.target.classList.contains('delete')){
          deletePreset(index);
        }else{
          applyPreset(preset);
        }
      });
      
      presetGrid.appendChild(card);
    });
  }

  function applyPreset(preset){
    selectEfecto.value = preset.efecto;
    umbralBordes.value = preset.umbral;
    intensidadGlow.value = preset.glow;
    nitidez.value = preset.nitidez;
    mezcla.value = preset.mezcla;
    colorPrincipal.value = preset.color;
    grosorLineas.value = preset.grosor;
    soloContornos.checked = preset.soloContornos;
    invertir.checked = preset.invertir;
    
    actualizarEtiquetasSliders();
    actualizarVisibilidadControles();
    aplicarEfectoSeleccionadoDebounced();
  }

  function deletePreset(index){
    let presets = JSON.parse(localStorage.getItem('artEffectsPresets') || '[]');
    presets.splice(index, 1);
    localStorage.setItem('artEffectsPresets', JSON.stringify(presets));
    loadPresets();
  }

  // ========== UI Functions ==========
  function restablecerAjustesPorEfecto(){
    const efecto = selectEfecto.value;
    const presets = {
      neon: {umbral:90, glow:35, nitidez:30, mezcla:80, color:'#00f5ff', grosor:3, soloContornos:true, invertir:false},
      cartoon: {umbral:70, glow:15, nitidez:25, mezcla:80, color:'#ff4500', grosor:4, soloContornos:false, invertir:false},
      simpsons: {umbral:60, glow:10, nitidez:10, mezcla:85, color:'#ffd90a', grosor:5, soloContornos:false, invertir:false},
      boceto: {umbral:70, glow:10, nitidez:40, mezcla:60, color:'#ffffff', grosor:3, soloContornos:true, invertir:true},
      poster: {umbral:80, glow:15, nitidez:10, mezcla:75, color:'#ff00ff', grosor:3, soloContornos:false, invertir:false},
      oleo: {umbral:60, glow:10, nitidez:5, mezcla:90, color:'#ffb347', grosor:2, soloContornos:false, invertir:false},
      acuarela: {umbral:50, glow:20, nitidez:0, mezcla:85, color:'#87ceeb', grosor:2, soloContornos:false, invertir:false},
      'comic-bw': {umbral:90, glow:10, nitidez:30, mezcla:70, color:'#000000', grosor:4, soloContornos:false, invertir:false},
      glitch: {umbral:80, glow:25, nitidez:15, mezcla:90, color:'#ff00ff', grosor:3, soloContornos:false, invertir:false}
    };

    const p = presets[efecto] || presets.neon;
    umbralBordes.value = p.umbral;
    intensidadGlow.value = p.glow;
    nitidez.value = p.nitidez;
    mezcla.value = p.mezcla;
    colorPrincipal.value = p.color;
    grosorLineas.value = p.grosor;
    soloContornos.checked = p.soloContornos;
    invertir.checked = p.invertir;

    actualizarEtiquetasSliders();
    actualizarVisibilidadControles();
  }

  function actualizarEtiquetasSliders(){
    valUmbral.textContent = umbralBordes.value;
    valGlow.textContent = intensidadGlow.value;
    valNitidez.textContent = nitidez.value;
    valMezcla.textContent = mezcla.value + '%';
    valGrosor.textContent = grosorLineas.value + 'px';
  }

  function actualizarVisibilidadControles(){
    const efecto = selectEfecto.value;
    const showGlow = ['neon','cartoon','poster','glitch'].includes(efecto);
    const showColor = ['neon','simpsons','poster'].includes(efecto);
    const showGrosor = ['cartoon','simpsons','boceto','neon','comic-bw'].includes(efecto);
    const showUmbral = ['neon','cartoon','simpsons','boceto','poster','comic-bw'].includes(efecto);

    grupoGlow.style.display = showGlow ? 'block' : 'none';
    grupoColor.style.display = showColor ? 'block' : 'none';
    grupoGrosor.style.display = showGrosor ? 'block' : 'none';
    grupoUmbral.style.display = showUmbral ? 'block' : 'none';
  }

  // ========== Event Listeners ==========
  
  // FIX iOS: Usar addEventListener normal, NO onchange en input oculto
  fileInput.addEventListener('change', e => {
    log('üìÇ Change event disparado');
    const archivo = e.target.files[0];
    cargarImagen(archivo);
  }, false);

  selectEfecto.addEventListener('change', () => {
    restablecerAjustesPorEfecto();
    aplicarEfectoSeleccionadoDebounced();
  });

  [umbralBordes,intensidadGlow,nitidez,mezcla,grosorLineas].forEach(input => {
    input.addEventListener('input', ()=>{
      actualizarEtiquetasSliders();
      aplicarEfectoSeleccionadoDebounced();
    });
  });

  [colorPrincipal,soloContornos,invertir,splitView].forEach(input => {
    input.addEventListener('change', aplicarEfectoSeleccionadoDebounced);
  });

  btnAplicar.addEventListener('click', aplicarEfectoSeleccionado);
  
  btnRestablecer.addEventListener('click', () => {
    restablecerAjustesPorEfecto();
    if(imagenOriginal){
      ctx.putImageData(imagenOriginal,0,0);
      aplicarEfectoSeleccionadoDebounced();
    }
  });

  btnDescargar.addEventListener('click', () => {
    try {
      const link = document.createElement('a');
      link.download = `efecto-${selectEfecto.value}-${Date.now()}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
      log('‚úÖ Descarga iniciada');
    } catch(e) {
      log(`‚ùå Error descarga: ${e.message}`);
    }
  });

  btnSavePreset.addEventListener('click', savePreset);

  // ========== Initialization ==========
  restablecerAjustesPorEfecto();
  actualizarVisibilidadControles();
  actualizarEtiquetasSliders();
  loadPresets();

  log('‚úÖ App lista - Optimizada para iPhone 16 Pro');
})();
</script>

</body>
</html>
