<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Editor de Efectos Art√≠sticos PRO - Estilo Clip2Comic</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
  :root{
    --bg:#0a0a0a;
    --panel:#141414;
    --accent:#ff5c5c;
    --accent-soft:#ffb347;
    --accent-cyan:#00d4ff;
    --text:#ffffff;
    --muted:#888888;
    --border:#2a2a2a;
  }
  *{box-sizing:border-box;margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;}
  body{
    background:radial-gradient(circle at top,#1a1a1a 0,#000 60%);
    color:var(--text);
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:12px;
  }
  .app{
    width:100%;
    max-width:1400px;
    background:var(--bg);
    border-radius:20px;
    box-shadow:0 0 60px rgba(255,92,92,0.15);
    overflow:hidden;
    border:1px solid var(--border);
  }
  header{
    padding:16px 20px;
    border-bottom:1px solid var(--border);
    background:linear-gradient(135deg,#0f0f0f,#1a1a1a 40%,#222);
  }
  header h1{
    font-size:1.2rem;
    letter-spacing:0.04em;
    background:linear-gradient(120deg,#ff5c5c,#ffb347,#00d4ff);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
  }
  .badge{
    font-size:0.65rem;
    padding:3px 8px;
    border-radius:12px;
    background:#222;
    color:var(--accent-cyan);
    border:1px solid #333;
    text-transform:uppercase;
    margin-left:8px;
  }
  main{display:flex;flex-direction:column;}
  .layout{display:flex;flex-direction:column;}
  @media(min-width:980px){.layout{flex-direction:row;}}
  .panel{padding:16px;}
  .panel.controls{
    background:var(--panel);
    border-right:1px solid var(--border);
    min-width:280px;
    max-height:90vh;
    overflow-y:auto;
    -webkit-overflow-scrolling:touch;
  }
  @media(min-width:980px){.panel.controls{width:360px;}}
  .panel.preview{flex:1;background:#000;}
  .section-title{
    font-size:0.85rem;
    text-transform:uppercase;
    color:var(--muted);
    letter-spacing:0.15em;
    margin:16px 0 10px;
    border-bottom:1px solid #222;
    padding-bottom:6px;
  }
  .section-title:first-child{margin-top:0;}
  .input-group{margin-bottom:12px;}
  label{display:block;font-size:0.82rem;margin-bottom:5px;color:#ccc;}
  .file-drop{
    border:2px dashed var(--border);
    border-radius:14px;
    padding:18px;
    text-align:center;
    background:#0f0f0f;
  }
  .file-drop input[type="file"]{
    opacity:1 !important;
    width:100%;
    padding:10px;
    font-size:14px;
    cursor:pointer;
    background:#1a1a1a;
    border:1px solid #333;
    border-radius:8px;
    color:#fff;
  }
  .file-drop p{font-size:0.75rem;color:var(--muted);margin-bottom:8px;}
  select,input[type="text"]{
    width:100%;
    padding:8px 10px;
    border-radius:10px;
    border:1px solid var(--border);
    background:#0a0a0a;
    color:var(--text);
    font-size:0.85rem;
  }
  .range-row{display:flex;align-items:center;gap:10px;}
  .range-value{min-width:40px;text-align:right;font-size:0.8rem;color:var(--accent-soft);font-weight:600;}
  input[type="range"]{
    width:100%;
    -webkit-appearance:none;
    height:5px;
    border-radius:999px;
    background:linear-gradient(to right,#222,#444);
  }
  input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none;
    width:18px;
    height:18px;
    border-radius:50%;
    background:linear-gradient(135deg,var(--accent),var(--accent-soft));
    cursor:pointer;
    border:2px solid #000;
  }
  .toggles{display:flex;gap:10px;flex-wrap:wrap;margin-top:4px;}
  .toggle{display:flex;align-items:center;gap:5px;font-size:0.76rem;color:#aaa;cursor:pointer;}
  .buttons{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px;}
  button{
    border:none;
    border-radius:999px;
    padding:9px 16px;
    font-size:0.8rem;
    cursor:pointer;
    background:#1a1a1a;
    color:var(--text);
    transition:all 0.2s;
    -webkit-tap-highlight-color:transparent;
  }
  button.primary{
    background:linear-gradient(120deg,#ff5c5c,#ffb347);
    color:#000;
    font-weight:600;
    box-shadow:0 0 16px rgba(255,92,92,0.4);
  }
  button.accent{background:var(--accent-cyan);color:#000;font-weight:600;}
  button:disabled{opacity:0.3;cursor:not-allowed;}
  button:active{transform:scale(0.96);}
  .canvas-wrapper{
    position:relative;
    width:100%;
    min-height:400px;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  canvas{max-width:100%;max-height:85vh;background:#000;}
  .placeholder{text-align:center;color:var(--muted);font-size:0.9rem;padding:40px 20px;}
  .spinner{
    position:absolute;
    right:16px;
    bottom:16px;
    width:32px;
    height:32px;
    border-radius:50%;
    border:4px solid rgba(255,255,255,0.1);
    border-top-color:var(--accent-soft);
    animation:spin 0.8s linear infinite;
    display:none;
  }
  .spinner.visible{display:block;}
  @keyframes spin{to{transform:rotate(360deg);}}
  .style-grid{
    display:grid;
    grid-template-columns:repeat(2,1fr);
    gap:8px;
    margin-top:8px;
  }
  .style-card{
    background:#1a1a1a;
    border:2px solid #333;
    border-radius:10px;
    padding:12px 8px;
    cursor:pointer;
    text-align:center;
    transition:all 0.2s;
  }
  .style-card.active{
    border-color:var(--accent);
    background:#252525;
  }
  .style-card:active{transform:scale(0.95);}
  .style-card .emoji{font-size:1.5rem;margin-bottom:4px;}
  .style-card .name{font-size:0.75rem;color:#fff;}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>‚ú® Editor Profesional de Efectos</h1>
    <span class="badge">Algoritmos PRO</span>
    <span class="badge">Estilo Clip2Comic</span>
  </header>

  <main>
    <div class="layout">
      <section class="panel controls">
        
        <div class="section-title">üì∏ Cargar Imagen</div>
        <div class="input-group">
          <div class="file-drop">
            <p><strong>üìÅ Seleccionar foto</strong></p>
            <input id="fileInput" type="file" accept="image/*" capture="environment" />
          </div>
        </div>

        <div class="section-title">üé® Estilos Art√≠sticos</div>
        <div class="style-grid" id="styleGrid"></div>

        <div class="section-title">‚öôÔ∏è Ajustes Avanzados</div>
        
        <div class="input-group">
          <label for="smoothing">Suavizado (Bilateral Filter)</label>
          <div class="range-row">
            <input id="smoothing" type="range" min="0" max="100" value="50" />
            <span class="range-value" id="valSmoothing">50</span>
          </div>
        </div>

        <div class="input-group">
          <label for="edgeStrength">Intensidad de bordes</label>
          <div class="range-row">
            <input id="edgeStrength" type="range" min="10" max="200" value="100" />
            <span class="range-value" id="valEdge">100</span>
          </div>
        </div>

        <div class="input-group">
          <label for="colorLevels">Niveles de color</label>
          <div class="range-row">
            <input id="colorLevels" type="range" min="4" max="32" value="12" />
            <span class="range-value" id="valColors">12</span>
          </div>
        </div>

        <div class="input-group">
          <label for="saturation">Saturaci√≥n</label>
          <div class="range-row">
            <input id="saturation" type="range" min="50" max="200" value="120" />
            <span class="range-value" id="valSat">120%</span>
          </div>
        </div>

        <div class="input-group">
          <label for="contrast">Contraste</label>
          <div class="range-row">
            <input id="contrast" type="range" min="50" max="200" value="110" />
            <span class="range-value" id="valCon">110%</span>
          </div>
        </div>

        <div class="toggles">
          <label class="toggle">
            <input id="useKMeans" type="checkbox" checked />
            <span>K-Means Clustering</span>
          </label>
          <label class="toggle">
            <input id="useBilateral" type="checkbox" checked />
            <span>Filtro Bilateral</span>
          </label>
        </div>

        <div class="buttons">
          <button class="primary" id="btnAplicar">üé® Aplicar Efecto</button>
          <button class="accent" id="btnDescargar" disabled>‚¨áÔ∏è Descargar HD</button>
        </div>
        
      </section>

      <section class="panel preview">
        <div class="canvas-wrapper">
          <canvas id="canvas"></canvas>
          <div id="placeholder" class="placeholder">
            üñºÔ∏è Carga una foto para comenzar<br>
            <span style="font-size:0.75rem;color:#666;">Algoritmos profesionales de procesamiento de imagen</span>
          </div>
          <div id="spinner" class="spinner"></div>
        </div>
      </section>
    </div>
  </main>
</div>

<script>
(() => {
  'use strict';

  const STYLES = [
    {id:'classic-comic', name:'C√≥mic Cl√°sico', emoji:'üì∞', params:{smooth:60,edge:120,colors:8,sat:130,con:120}},
    {id:'vibrant-pop', name:'Pop Art Vibrante', emoji:'üé®', params:{smooth:70,edge:140,colors:12,sat:150,con:130}},
    {id:'manga', name:'Manga japon√©s', emoji:'üìö', params:{smooth:40,edge:180,colors:6,sat:100,con:140}},
    {id:'neon-glow', name:'Ne√≥n Intenso', emoji:'‚ö°', params:{smooth:50,edge:150,colors:16,sat:180,con:120}},
    {id:'vintage-comic', name:'C√≥mic Vintage', emoji:'üìñ', params:{smooth:80,edge:100,colors:10,sat:90,con:110}},
    {id:'modern-cartoon', name:'Cartoon Moderno', emoji:'üé≠', params:{smooth:65,edge:130,colors:14,sat:140,con:115}},
    {id:'sketch-art', name:'Arte Boceto', emoji:'‚úèÔ∏è', params:{smooth:30,edge:200,colors:4,sat:80,con:150}},
    {id:'watercolor', name:'Acuarela Digital', emoji:'üíß', params:{smooth:90,edge:80,colors:20,sat:110,con:100}},
  ];

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', {willReadFrequently:true});
  const fileInput = document.getElementById('fileInput');
  const placeholder = document.getElementById('placeholder');
  const spinner = document.getElementById('spinner');
  const styleGrid = document.getElementById('styleGrid');
  const btnAplicar = document.getElementById('btnAplicar');
  const btnDescargar = document.getElementById('btnDescargar');

  const smoothing = document.getElementById('smoothing');
  const edgeStrength = document.getElementById('edgeStrength');
  const colorLevels = document.getElementById('colorLevels');
  const saturation = document.getElementById('saturation');
  const contrast = document.getElementById('contrast');
  const useKMeans = document.getElementById('useKMeans');
  const useBilateral = document.getElementById('useBilateral');

  const valSmoothing = document.getElementById('valSmoothing');
  const valEdge = document.getElementById('valEdge');
  const valColors = document.getElementById('valColors');
  const valSat = document.getElementById('valSat');
  const valCon = document.getElementById('valCon');

  let imagenOriginal = null;
  let imagenBase = null;
  let currentStyle = 'classic-comic';
  let processingTimeout = null;

  // ========== Render styles grid ==========
  STYLES.forEach(style => {
    const card = document.createElement('div');
    card.className = 'style-card';
    if(style.id === currentStyle) card.classList.add('active');
    card.innerHTML = `<div class="emoji">${style.emoji}</div><div class="name">${style.name}</div>`;
    card.onclick = () => {
      document.querySelectorAll('.style-card').forEach(c => c.classList.remove('active'));
      card.classList.add('active');
      currentStyle = style.id;
      applyStylePreset(style.params);
    };
    styleGrid.appendChild(card);
  });

  function applyStylePreset(params){
    smoothing.value = params.smooth;
    edgeStrength.value = params.edge;
    colorLevels.value = params.colors;
    saturation.value = params.sat;
    contrast.value = params.con;
    updateLabels();
    if(imagenOriginal) aplicarEfectoDebounced();
  }

  function updateLabels(){
    valSmoothing.textContent = smoothing.value;
    valEdge.textContent = edgeStrength.value;
    valColors.textContent = colorLevels.value;
    valSat.textContent = saturation.value + '%';
    valCon.textContent = contrast.value + '%';
  }

  [smoothing,edgeStrength,colorLevels,saturation,contrast].forEach(input => {
    input.addEventListener('input', () => {
      updateLabels();
      aplicarEfectoDebounced();
    });
  });

  [useKMeans,useBilateral].forEach(input => {
    input.addEventListener('change', aplicarEfectoDebounced);
  });

  function mostrarSpinner(show){
    spinner.classList.toggle('visible', show);
  }

  function clamp(v, min, max){
    return v < min ? min : (v > max ? max : v);
  }

  // ========== Load Image ==========
  fileInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if(!file) return;

    const reader = new FileReader();
    reader.onload = e => {
      const img = new Image();
      img.onload = () => {
        imagenBase = img;
        const maxDim = 1500;
        let w = img.width;
        let h = img.height;
        const ratio = Math.min(1, maxDim / Math.max(w,h));
        w = Math.round(w * ratio);
        h = Math.round(h * ratio);
        
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(img, 0, 0, w, h);
        imagenOriginal = ctx.getImageData(0,0,w,h);
        placeholder.style.display = 'none';
        btnDescargar.disabled = false;
        aplicarEfectoDebounced();
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });

  function aplicarEfectoDebounced(){
    if(!imagenOriginal) return;
    clearTimeout(processingTimeout);
    processingTimeout = setTimeout(aplicarEfecto, 150);
  }

  // ========== ADVANCED IMAGE PROCESSING ==========
  
  function aplicarEfecto(){
    if(!imagenOriginal) return;
    mostrarSpinner(true);

    setTimeout(() => {
      try {
        const w = imagenOriginal.width;
        const h = imagenOriginal.height;
        let imgData = new ImageData(new Uint8ClampedArray(imagenOriginal.data), w, h);

        // Step 1: Median filter to reduce noise
        imgData = medianFilter(imgData);

        // Step 2: Bilateral filter (edge-preserving smoothing)
        if(useBilateral.checked){
          const smoothVal = parseInt(smoothing.value) / 100;
          imgData = bilateralFilter(imgData, smoothVal);
        }

        // Step 3: Adjust saturation and contrast
        imgData = adjustSaturationContrast(imgData, 
          parseInt(saturation.value) / 100, 
          parseInt(contrast.value) / 100
        );

        // Step 4: Color quantization (K-means clustering)
        if(useKMeans.checked){
          const numColors = parseInt(colorLevels.value);
          imgData = kMeansQuantization(imgData, numColors);
        }

        // Step 5: Edge detection and enhancement
        const edges = sobelEdgeDetection(imgData, parseInt(edgeStrength.value));
        
        // Step 6: Combine edges with color image
        imgData = combineEdgesWithColor(imgData, edges);

        ctx.putImageData(imgData, 0, 0);
        mostrarSpinner(false);
      } catch(e) {
        console.error(e);
        mostrarSpinner(false);
      }
    }, 50);
  }

  // ========== Median Filter (noise reduction) ==========
  function medianFilter(imgData){
    const w = imgData.width, h = imgData.height;
    const src = imgData.data;
    const out = new Uint8ClampedArray(src.length);
    
    for(let y=1; y<h-1; y++){
      for(let x=1; x<w-1; x++){
        const rVals = [], gVals = [], bVals = [];
        
        for(let ky=-1; ky<=1; ky++){
          for(let kx=-1; kx<=1; kx++){
            const idx = ((y+ky)*w + (x+kx)) * 4;
            rVals.push(src[idx]);
            gVals.push(src[idx+1]);
            bVals.push(src[idx+2]);
          }
        }
        
        rVals.sort((a,b) => a-b);
        gVals.sort((a,b) => a-b);
        bVals.sort((a,b) => a-b);
        
        const idx = (y*w + x) * 4;
        out[idx] = rVals[4];
        out[idx+1] = gVals[4];
        out[idx+2] = bVals[4];
        out[idx+3] = 255;
      }
    }
    
    // Copy edges
    for(let i=0; i<src.length; i++) if(out[i]===0) out[i] = src[i];
    
    return new ImageData(out, w, h);
  }

  // ========== Bilateral Filter (edge-preserving smoothing) ==========
  function bilateralFilter(imgData, strength){
    const w = imgData.width, h = imgData.height;
    const src = imgData.data;
    const out = new Uint8ClampedArray(src.length);
    
    const radius = Math.round(3 * strength) || 1;
    const sigmaSpace = radius;
    const sigmaColor = 50 * strength;
    
    for(let y=0; y<h; y++){
      for(let x=0; x<w; x++){
        const idx = (y*w + x) * 4;
        const centerR = src[idx];
        const centerG = src[idx+1];
        const centerB = src[idx+2];
        
        let sumR=0, sumG=0, sumB=0, sumWeight=0;
        
        for(let ky=-radius; ky<=radius; ky++){
          for(let kx=-radius; kx<=radius; kx++){
            const ny = clamp(y+ky, 0, h-1);
            const nx = clamp(x+kx, 0, w-1);
            const nidx = (ny*w + nx) * 4;
            
            const nr = src[nidx];
            const ng = src[nidx+1];
            const nb = src[nidx+2];
            
            // Spatial weight
            const spatialDist = Math.sqrt(kx*kx + ky*ky);
            const spatialWeight = Math.exp(-(spatialDist*spatialDist) / (2*sigmaSpace*sigmaSpace));
            
            // Color weight
            const colorDist = Math.sqrt(
              (nr-centerR)*(nr-centerR) + 
              (ng-centerG)*(ng-centerG) + 
              (nb-centerB)*(nb-centerB)
            );
            const colorWeight = Math.exp(-(colorDist*colorDist) / (2*sigmaColor*sigmaColor));
            
            const weight = spatialWeight * colorWeight;
            
            sumR += nr * weight;
            sumG += ng * weight;
            sumB += nb * weight;
            sumWeight += weight;
          }
        }
        
        out[idx] = sumR / sumWeight;
        out[idx+1] = sumG / sumWeight;
        out[idx+2] = sumB / sumWeight;
        out[idx+3] = 255;
      }
    }
    
    return new ImageData(out, w, h);
  }

  // ========== Saturation & Contrast ==========
  function adjustSaturationContrast(imgData, satFactor, conFactor){
    const d = imgData.data;
    
    for(let i=0; i<d.length; i+=4){
      let r = d[i], g = d[i+1], b = d[i+2];
      
      // Saturation
      const gray = 0.299*r + 0.587*g + 0.114*b;
      r = gray + (r - gray) * satFactor;
      g = gray + (g - gray) * satFactor;
      b = gray + (b - gray) * satFactor;
      
      // Contrast
      r = ((r/255 - 0.5) * conFactor + 0.5) * 255;
      g = ((g/255 - 0.5) * conFactor + 0.5) * 255;
      b = ((b/255 - 0.5) * conFactor + 0.5) * 255;
      
      d[i] = clamp(r, 0, 255);
      d[i+1] = clamp(g, 0, 255);
      d[i+2] = clamp(b, 0, 255);
    }
    
    return imgData;
  }

  // ========== K-Means Color Quantization ==========
  function kMeansQuantization(imgData, k){
    const w = imgData.width, h = imgData.height;
    const d = imgData.data;
    const pixels = [];
    
    // Sample pixels (use every 4th pixel for speed)
    for(let i=0; i<d.length; i+=16){
      pixels.push([d[i], d[i+1], d[i+2]]);
    }
    
    // Initialize centroids randomly
    const centroids = [];
    const used = new Set();
    while(centroids.length < k){
      const idx = Math.floor(Math.random() * pixels.length);
      const key = pixels[idx].join(',');
      if(!used.has(key)){
        centroids.push([...pixels[idx]]);
        used.add(key);
      }
    }
    
    // K-means iterations
    for(let iter=0; iter<5; iter++){
      const clusters = Array(k).fill(null).map(() => []);
      
      // Assign pixels to nearest centroid
      for(const pixel of pixels){
        let minDist = Infinity;
        let bestCluster = 0;
        
        for(let j=0; j<k; j++){
          const dist = Math.sqrt(
            (pixel[0]-centroids[j][0])**2 +
            (pixel[1]-centroids[j][1])**2 +
            (pixel[2]-centroids[j][2])**2
          );
          if(dist < minDist){
            minDist = dist;
            bestCluster = j;
          }
        }
        
        clusters[bestCluster].push(pixel);
      }
      
      // Update centroids
      for(let j=0; j<k; j++){
        if(clusters[j].length === 0) continue;
        
        const sumR = clusters[j].reduce((s,p) => s+p[0], 0);
        const sumG = clusters[j].reduce((s,p) => s+p[1], 0);
        const sumB = clusters[j].reduce((s,p) => s+p[2], 0);
        const len = clusters[j].length;
        
        centroids[j] = [sumR/len, sumG/len, sumB/len];
      }
    }
    
    // Map all pixels to nearest centroid
    for(let i=0; i<d.length; i+=4){
      const pixel = [d[i], d[i+1], d[i+2]];
      let minDist = Infinity;
      let bestColor = centroids[0];
      
      for(const centroid of centroids){
        const dist = Math.sqrt(
          (pixel[0]-centroid[0])**2 +
          (pixel[1]-centroid[1])**2 +
          (pixel[2]-centroid[2])**2
        );
        if(dist < minDist){
          minDist = dist;
          bestColor = centroid;
        }
      }
      
      d[i] = bestColor[0];
      d[i+1] = bestColor[1];
      d[i+2] = bestColor[2];
    }
    
    return imgData;
  }

  // ========== Sobel Edge Detection ==========
  function sobelEdgeDetection(imgData, threshold){
    const w = imgData.width, h = imgData.height;
    const src = imgData.data;
    const edges = new Uint8ClampedArray(w*h);
    
    for(let y=1; y<h-1; y++){
      for(let x=1; x<w-1; x++){
        let gx = 0, gy = 0;
        
        for(let ky=-1; ky<=1; ky++){
          for(let kx=-1; kx<=1; kx++){
            const idx = ((y+ky)*w + (x+kx)) * 4;
            const gray = 0.299*src[idx] + 0.587*src[idx+1] + 0.114*src[idx+2];
            
            const sobelX = kx;
            const sobelY = ky;
            
            gx += gray * sobelX;
            gy += gray * sobelY;
          }
        }
        
        const magnitude = Math.sqrt(gx*gx + gy*gy);
        edges[y*w + x] = magnitude > threshold ? 255 : 0;
      }
    }
    
    return edges;
  }

  // ========== Combine Edges with Color ==========
  function combineEdgesWithColor(imgData, edges){
    const d = imgData.data;
    
    for(let i=0; i<edges.length; i++){
      if(edges[i] > 128){
        const idx = i * 4;
        d[idx] = 0;
        d[idx+1] = 0;
        d[idx+2] = 0;
        d[idx+3] = 255;
      }
    }
    
    return imgData;
  }

  // ========== Download ==========
  btnDescargar.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = `comic-effect-${currentStyle}-${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  btnAplicar.addEventListener('click', aplicarEfecto);

  // Init
  updateLabels();
  applyStylePreset(STYLES[0].params);
})();
</script>
</body>
</html>
